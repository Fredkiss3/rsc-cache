import "server-only";

// components
import { CacheClient } from "../client/cache-client.js";

// utils
import * as React from "react";
import { renderRSCtoString } from "./render-rsc-to-string.js";

// types
export type CacheId = string | number | (string | number)[];
export type CacheProps = {
  id: CacheId;
  ttl?: number;
  /**
   * Default to `false`, If `true` this will apply cache in development.
   * This is not recommended as it could cause out-of-date issues when modifying your components.
   */
  cacheInDEV?: boolean;
  /**
   * If true, outputs the cached payload for debugging.
   */
  debugPayload?: boolean;
  children: React.ReactNode;
  /**
   * The function to handle caching logic.
   * @param generatePayload - the function that generates the payload that will be cached
   * @param cacheKey - the computed cacheKey
   * @param ttl - the ttl passed to the component, if you set a defaultTTL in `createCacheComponent`,
   *              it will have that value, if you did override the ttl in one `<Cache />` call, it
   *              will have that value instead.
   * @returns the cache payload
   */
  cacheFn: (
    generatePayload: () => Promise<string>,
    cacheKey: string,
    ttl?: number
  ) => Promise<string>;
  /**
   * function to get the `BUILD_ID` generated by nextjs,
   * this ID is used to compute the cache key and avoid
   * having outdated components in the cache.
   */
  getBuildId: () => Promise<string> | string;
};

async function Cache({
  id,
  ttl,
  cacheInDEV = false,
  children,
  debugPayload = false,
  cacheFn,
  getBuildId
}: CacheProps) {
  if (!cacheInDEV && process.env.NODE_ENV === "development") {
    return <>{children}</>;
  }

  const cacheKey = await computeCacheKey(id, getBuildId);

  const renderRSC = async () => {
    return await renderRSCtoString(children);
  };
  const cachedPayload = await cacheFn(renderRSC, cacheKey, ttl);

  if (debugPayload) {
    return (
      <pre
        style={{
          maxWidth: "100%",
          overflow: "auto"
        }}
      >
        {cachedPayload}
      </pre>
    );
  }

  return <CacheClient payload={cachedPayload} />;
}

export async function computeCacheKey(
  id: CacheId,
  getBuildId: () => Promise<string> | string
) {
  let fullKey = Array.isArray(id) ? id.join("-") : id.toString();

  // the build ID is necessary because the client references for one build
  // won't necessarily be the same for another build, especially if the component
  // changed in the meantime
  const buildId = await getBuildId();
  if (!buildId && typeof buildId !== "string") {
    throw new Error(
      "The BUILD ID must be defined in order for the cache to work, see https://github.com/Fredkiss3/rsc-cache#troubleshooting to resolve this error"
    );
  }
  fullKey += `-${buildId}`;
  return fullKey;
}

type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};
type CreateCacheComponentArgs = Prettify<
  Pick<CacheProps, "cacheFn" | "getBuildId"> & {
    defaultTTL?: number;
  }
>;

export function createCacheComponent({
  cacheFn,
  getBuildId,
  defaultTTL
}: CreateCacheComponentArgs) {
  return (props: Omit<CacheProps, "cacheFn" | "getBuildId">) => (
    // @ts-expect-error Idk why this is causing issues while we installed the latest versions of TS & react types packages
    <Cache
      {...props}
      cacheFn={cacheFn}
      getBuildId={getBuildId}
      ttl={props.ttl ?? defaultTTL}
    />
  );
}
